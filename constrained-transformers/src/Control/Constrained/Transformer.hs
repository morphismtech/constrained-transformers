{-# LANGUAGE
DefaultSignatures
, FlexibleInstances
, FunctionalDependencies
, MultiParamTypeClasses
, PolyKinds
, QuantifiedConstraints
, RankNTypes
, TypeOperators
, UndecidableInstances
, UndecidableSuperClasses
#-}

module Control.Constrained.Transformer
  ( Unconstrained
  , (:&&)
  , CFunctor (cmap)
  , CTrans (creturn)
  , CMonad (cjoin, cbind)
  , CCotrans (cextract)
  , CComonad (cduplicate, cextend)
  , CFree (cram), coerceCFree
  , C1Functor (hoist)
  , C1Trans (lift)
  , C1Monad (squash, embed)
  , C1Cotrans (lower)
  , C1Comonad (diagonal, expand)
  , C1Free (crush), coerceC1Free
  ) where

import qualified Control.Monad.Morph as Morph
import Control.Monad.State (MonadState(..))
import qualified Control.Monad.Trans.State.Strict as S'
import Data.Foldable
import qualified Data.Set as Set
import Data.Set (Set)

class Unconstrained t
instance Unconstrained t

class (c t, d t) => (c :&& d) t
instance (c t, d t) => (c :&& d) t

class (forall a. c a => d (f a))
  => CFunctor c d f | f -> c, f -> d where
    -- prop> cmap id = id
    -- prop> cmap (g . f) = cmap g . cmap f
    cmap :: (c a, c b) => (a -> b) -> f a -> f b
    default cmap :: Functor f => (a -> b) -> f a -> f b
    cmap = fmap
instance CFunctor Unconstrained Monoid []
instance CFunctor Ord (Ord :&& Monoid) Set where cmap = Set.map

class CFunctor c d f
  => CTrans c d f where
    -- prop> cmap f . creturn = creturn . f
    creturn :: c a => a -> f a
    default creturn :: Applicative f => a -> f a
    creturn = pure
instance CTrans Unconstrained Monoid []
instance CTrans Ord (Ord :&& Monoid) Set where creturn = Set.singleton

class CTrans c d f
  => CMonad c d f where
    cjoin :: (forall x. d x => c x, c a) => f (f a) -> f a
    cjoin = cbind id
    cbind :: (forall x. d x => c x, c a, c b) => (a -> f b) -> f a -> f b
    cbind f a = cjoin (cmap f a)
instance CMonad Unconstrained Monoid [] where cbind = foldMap
instance CMonad Ord (Ord :&& Monoid) Set where cbind = foldMap

class CFunctor c d f
  => CCotrans c d f where
    -- prop> cextract . cmap f = f . cextract
    cextract :: d a => f a -> a
instance CCotrans Unconstrained Monoid [] where cextract = fold
instance CCotrans Ord (Ord :&& Monoid) Set where cextract = fold

class CCotrans c d f
  => CComonad c d f where
    cduplicate :: (forall x. d x => c x, d a) => f a -> f (f a)
    cduplicate = cextend id
    cextend :: (forall x. d x => c x, d a, d b) => (f a -> b) -> f a -> f b
    cextend f a = cmap f (cduplicate a)
instance CComonad Unconstrained Monoid [] where cduplicate = cmap creturn
instance CComonad Ord (Ord :&& Monoid) Set where cduplicate = cmap creturn

{- | @CFree c d f@ witnesses an adjunction
between forgetting `forall a. d a => c a`
and `f` the free `d` generated by a `c`.
-}
class (CMonad c d free, CComonad c d free)
  => CFree c d free where
    -- prop> cram f . single = f
    -- prop> cbind = cram
    -- prop> cextract = cram id
    cram :: (c a, d b) => (a -> b) -> free a -> b
instance CFree Unconstrained Monoid [] where cram = foldMap
instance CFree Ord (Ord :&& Monoid) Set where cram = foldMap

coerceCFree
  :: forall free1 free0 c d a. (CFree c d free0, CFree c d free1, c a)
  => free0 a -> free1 a
coerceCFree = cram creturn

class (forall f. c f => d (t f))
  => C1Functor c d t | t -> c, t -> d where
    -- prop> hoist id = id
    -- prop> hoist (g . f) = hoist g . hoist f
    hoist
      :: (c f, c g)
      => (forall x. f x -> g x)
      -> t f a -> t g a
    default hoist
      :: (Morph.MFunctor t, Monad f)
      => (forall x. f x -> g x)
      -> t f a -> t g a
    hoist = Morph.hoist
instance C1Functor Monad (MonadState s) (S'.StateT s)

class C1Functor c d t
  => C1Trans c d t where
    -- prop> hoist f . lift = lift . f
    lift :: c f => f a -> t f a
    default lift :: (Morph.MonadTrans t, Monad f) => f a -> t f a
    lift = Morph.lift
instance C1Trans Monad (MonadState s) (S'.StateT s)

class C1Trans c d t
  => C1Monad c d t where
    squash :: (forall f. d f => c f, c m) => t (t m) a -> t m a
    squash = embed id
    embed
      :: (forall f. d f => c f, c m, c n)
      => (forall x. m x -> t n x)
      -> t m a -> t n a
    embed f a = squash (hoist f a)
instance C1Monad Monad (MonadState s) (S'.StateT s) where
  embed = crush

class C1Functor c d t
  => C1Cotrans c d t where
    -- prop> lower . hoist f = f . lower
    lower :: d f => t f a -> f a
instance C1Cotrans Monad (MonadState s) (S'.StateT s) where
  lower = crush id

class (C1Cotrans c d t)
  => C1Comonad c d t where
    diagonal :: (forall f. d f => c f, d w) => t w a -> t (t w) a
    diagonal = expand id
    expand
      :: (forall f. d f => c f, d v, d w)
      => (forall x. t v x -> w x)
      -> t v a -> t w a
    expand f a = hoist f (diagonal a)
instance C1Comonad Monad (MonadState s) (S'.StateT s) where
  diagonal = hoist lift

{- | @C1Free c d free@ witnesses an adjunction
between forgetful constrained functor from @d@ to @c@
induced by the quantified constraint @forall f. d f => c f@
and @free@ the free constrained functor from @c@ to @d@.
-}
class (C1Monad c d free, C1Comonad c d free)
  => C1Free c d free where
    -- prop> crush f . lift = f
    -- prop> embed = crush
    -- prop> lower = crush id
    crush
      :: (c f, d g)
      => (forall x. f x -> g x)
      -> free f a -> g a
instance C1Free Monad (MonadState s) (S'.StateT s) where
  crush f st = do
    s <- get
    (a, s') <- S'.runStateT (hoist f st) s
    put s'
    return a

coerceC1Free
  :: forall free1 free0 c d f a. (C1Free c d free0, C1Free c d free1, c f)
  => free0 f a -> free1 f a
coerceC1Free = crush lift
